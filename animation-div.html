<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cursor Animations</title>
    <style>

        .trail-image {
            position: fixed;
            pointer-events: none;
            width: 150px;
            height: 100px;
            transform: translate(-50%, -50%) scale(0.3); /* Initial scale */
            opacity: 0; /* Start with opacity 0 */
            border-radius: 12px;
            overflow: hidden;
            transition: opacity 1s ease, transform 1s ease; /* Slower transitions */
        }

        .trail-image.active {
            opacity: 1; /* Fully visible when active */
            transform: translate(-50%, -50%) scale(1); /* Scale up to normal size */
        }

        .trail-image.fade-out {
            opacity: 0; /* Fade out */
            transform: translate(-50%, -50%) scale(0.5); /* Slightly scale down while fading out */
        }


        .hover-trigger {
            cursor: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

    </style>
</head>
<body>
    <div class="hover-trigger" data-images="./images/image1.jpg,./images/image2.jpg,./images/image3.jpg">
        Custom images for this area
    </div>
    <script>

class CursorTrail {
    constructor() {
        this.images = [
            'path/to/image1.jpg',
            'path/to/image2.jpg',
            'path/to/image3.jpg'
        ];
        this.currentIndex = 0;
        this.timeouts = [];
        this.lastMoveTime = 0;
        this.moveThreshold = 10; // Increased threshold for smoother appearance
        this.lastX = 0;
        this.lastY = 0;
        this.isHovering = false; // Track hover state
        
        this.init();
    }

    init() {
        const hoverElements = document.querySelectorAll('.hover-trigger');
        
        hoverElements.forEach(element => {
            element.addEventListener('mouseenter', () => {
                this.isHovering = true;
            });
            const customImages = element.dataset.images;
            if (customImages) {
                this.images = customImages.split(',');
                this.currentIndex = 0;    
            }
            element.addEventListener('mouseleave', () => {
                this.isHovering = false;
                this.clearTrail();
            });
        });

        // Throttle the mousemove event
        document.addEventListener('mousemove', this.throttle(this.handleMouseMove.bind(this), 50));
    }

    throttle(callback, delay) {
        let lastCall = 0;
        return function (...args) {
            const now = Date.now();
            if (now - lastCall < delay) return;
            lastCall = now;
            return callback(...args);
        };
    }

    clearTrail() {
        const trails = document.querySelectorAll('.trail-image');
        trails.forEach(trail => {
            trail.classList.add('fade-out');
            setTimeout(() => trail.remove(), 500);
        });
    }

    createTrailElement(x, y) {
        // Only create trail if hovering
        if (!this.isHovering) return;

        const trail = document.createElement('div');
        trail.className = 'trail-image';

        const img = document.createElement('img');
        img.src = this.images[this.currentIndex];
        trail.appendChild(img);

        document.body.appendChild(trail);

        const initialScale = 0.3 + Math.random() * 0.2; // Random scale

        trail.style.left = `${x}px`;
        trail.style.top = `${y}px`;
        // Set the transform without rotation
        trail.style.transform = `translate(-50%, -50%) scale(${initialScale})`;

        requestAnimationFrame(() => {
            trail.classList.add('active');
        });

        // Increase the timeout for how long the image stays active
        const timeout = setTimeout(() => {
            trail.classList.add('fade-out');
            trail.classList.remove('active');

            // Remove after fade out
            setTimeout(() => {
                trail.remove();
            }, 1000); // Match the duration of fade-out transition
        }, 2000); // Active for longer duration (2 seconds)

        this.timeouts.push(timeout);
        this.currentIndex = (this.currentIndex + 1) % this.images.length;
    }



    handleMouseMove(e) {
        if (!this.isHovering) return;

        const currentTime = Date.now();
        const dx = e.clientX - this.lastX;
        const dy = e.clientY - this.lastY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Only create a new trail element if the mouse has moved a sufficient distance
        if (distance > this.moveThreshold) {
            this.createTrailElement(e.clientX, e.clientY);
            this.lastMoveTime = currentTime;
            this.lastX = e.clientX;
            this.lastY = e.clientY;
        }
    }

    destroy() {
        this.timeouts.forEach(timeout => clearTimeout(timeout));
        this.clearTrail();
        document.removeEventListener('mousemove', this.handleMouseMove);

        const hoverElements = document.querySelectorAll('.hover-trigger');
        hoverElements.forEach(element => {
            element.removeEventListener('mouseenter', () => {});
            element.removeEventListener('mouseleave', () => {});
        });
    }
}

// Initialize
const cursorTrail = new CursorTrail();

    </script>
</body>
</html>